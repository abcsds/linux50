diff --git a/drivers/hid/i2c-hid/Makefile b/drivers/hid/i2c-hid/Makefile
index 099e1ce2f234..c0641588bf74 100644
--- a/drivers/hid/i2c-hid/Makefile
+++ b/drivers/hid/i2c-hid/Makefile
@@ -2,7 +2,8 @@
 # Makefile for the I2C input drivers
 #
 
-obj-$(CONFIG_I2C_HID)				+= i2c-hid.o
+obj-$(CONFIG_I2C_HID)  += i2c-hid.o
+
+i2c-hid-objs            = i2c-hid-core.o
+i2c-hid-$(CONFIG_DMI)  += i2c-hid-dmi-quirks.o
 
-i2c-hid-objs					=  i2c-hid-core.o
-i2c-hid-$(CONFIG_DMI)				+= i2c-hid-dmi-quirks.o
diff --git a/drivers/hid/i2c-hid/i2c-hid-core.c b/drivers/hid/i2c-hid/i2c-hid-core.c
index c5edfa966343..2e1a2fe1ebfe 100644
--- a/drivers/hid/i2c-hid/i2c-hid-core.c
+++ b/drivers/hid/i2c-hid/i2c-hid-core.c
@@ -48,8 +48,7 @@
 /* quirks to control the device */
 #define I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV	BIT(0)
 #define I2C_HID_QUIRK_NO_IRQ_AFTER_RESET	BIT(1)
-#define I2C_HID_QUIRK_NO_RUNTIME_PM		BIT(2)
-#define I2C_HID_QUIRK_DELAY_AFTER_SLEEP		BIT(3)
+#define I2C_HID_QUIRK_RESEND_REPORT_DESCR	BIT(2)
 
 /* flags */
 #define I2C_HID_STARTED		0
@@ -133,6 +132,8 @@ static const struct i2c_hid_cmd hid_no_cmd =		{ .length = 0 };
  * static const struct i2c_hid_cmd hid_set_protocol_cmd = { I2C_HID_CMD(0x07) };
  */
 
+static DEFINE_MUTEX(i2c_hid_open_mut);
+
 /* The main device structure */
 struct i2c_hid {
 	struct i2c_client	*client;	/* i2c client */
@@ -159,8 +160,6 @@ struct i2c_hid {
 
 	bool			irq_wake_enabled;
 	struct mutex		reset_lock;
-
-	unsigned long		sleep_delay;
 };
 
 static const struct i2c_hid_quirks {
@@ -173,14 +172,9 @@ static const struct i2c_hid_quirks {
 	{ USB_VENDOR_ID_WEIDA, USB_DEVICE_ID_WEIDA_8755,
 		I2C_HID_QUIRK_SET_PWR_WAKEUP_DEV },
 	{ I2C_VENDOR_ID_HANTICK, I2C_PRODUCT_ID_HANTICK_5288,
-		I2C_HID_QUIRK_NO_IRQ_AFTER_RESET |
-		I2C_HID_QUIRK_NO_RUNTIME_PM },
-	{ I2C_VENDOR_ID_RAYDIUM, I2C_PRODUCT_ID_RAYDIUM_4B33,
-		I2C_HID_QUIRK_DELAY_AFTER_SLEEP },
-	{ USB_VENDOR_ID_LG, I2C_DEVICE_ID_LG_8001,
-		I2C_HID_QUIRK_NO_RUNTIME_PM },
-	{ I2C_VENDOR_ID_GOODIX, I2C_DEVICE_ID_GOODIX_01F0,
-		I2C_HID_QUIRK_NO_RUNTIME_PM },
+		I2C_HID_QUIRK_NO_IRQ_AFTER_RESET },
+	{ I2C_VENDOR_ID_RAYD, I2C_PRODUCT_ID_RAYD_3118,
+		I2C_HID_QUIRK_RESEND_REPORT_DESCR },
 	{ 0, 0 }
 };
 
@@ -396,7 +390,6 @@ static int i2c_hid_set_power(struct i2c_client *client, int power_state)
 {
 	struct i2c_hid *ihid = i2c_get_clientdata(client);
 	int ret;
-	unsigned long now, delay;
 
 	i2c_hid_dbg(ihid, "%s\n", __func__);
 
@@ -414,22 +407,9 @@ static int i2c_hid_set_power(struct i2c_client *client, int power_state)
 			goto set_pwr_exit;
 	}
 
-	if (ihid->quirks & I2C_HID_QUIRK_DELAY_AFTER_SLEEP &&
-	    power_state == I2C_HID_PWR_ON) {
-		now = jiffies;
-		if (time_after(ihid->sleep_delay, now)) {
-			delay = jiffies_to_usecs(ihid->sleep_delay - now);
-			usleep_range(delay, delay + 1);
-		}
-	}
-
 	ret = __i2c_hid_command(client, &hid_set_power_cmd, power_state,
 		0, NULL, 0, NULL, 0);
 
-	if (ihid->quirks & I2C_HID_QUIRK_DELAY_AFTER_SLEEP &&
-	    power_state == I2C_HID_PWR_SLEEP)
-		ihid->sleep_delay = jiffies + msecs_to_jiffies(20);
-
 	if (ret)
 		dev_err(&client->dev, "failed to change power setting.\n");
 
@@ -505,7 +485,7 @@ static void i2c_hid_get_input(struct i2c_hid *ihid)
 		return;
 	}
 
-	if ((ret_size > size) || (ret_size < 2)) {
+	if ((ret_size > size) || (ret_size <= 2)) {
 		dev_err(&ihid->client->dev, "%s: incomplete report (%d/%d)\n",
 			__func__, size, ret_size);
 		return;
@@ -711,24 +691,24 @@ static int i2c_hid_parse(struct hid_device *hid)
 	if (ret)
 		return ret;
 
-	use_override = i2c_hid_get_dmi_hid_report_desc_override(client->name,
-								&rsize);
+	use_override=i2c_hid_get_dmi_hid_report_desc_override(&rsize);
 
-	if (use_override) {
+	if(use_override) {
 		rdesc = use_override;
 		i2c_hid_dbg(ihid, "Using a HID report descriptor override\n");
-	} else {
+	}
+	
+	else {
 		rdesc = kzalloc(rsize, GFP_KERNEL);
-
+		
 		if (!rdesc) {
 			dbg_hid("couldn't allocate rdesc memory\n");
 			return -ENOMEM;
 		}
-
+		
 		i2c_hid_dbg(ihid, "asking HID report descriptor\n");
-
-		ret = i2c_hid_command(client, &hid_report_descr_cmd,
-				      rdesc, rsize);
+		
+		ret = i2c_hid_command(client, &hid_report_descr_cmd, rdesc, rsize);
 		if (ret) {
 			hid_err(hid, "reading report descriptor failed\n");
 			kfree(rdesc);
@@ -739,9 +719,9 @@ static int i2c_hid_parse(struct hid_device *hid)
 	i2c_hid_dbg(ihid, "Report Descriptor: %*ph\n", rsize, rdesc);
 
 	ret = hid_parse_report(hid, rdesc, rsize);
-	if (!use_override)
+	if(!use_override)
 		kfree(rdesc);
-
+	
 	if (ret) {
 		dbg_hid("parsing report descriptor failed\n");
 		return ret;
@@ -868,14 +848,13 @@ static int i2c_hid_fetch_hid_descriptor(struct i2c_hid *ihid)
 	int ret;
 
 	/* i2c hid fetch using a fixed descriptor size (30 bytes) */
-	if (i2c_hid_get_dmi_i2c_hid_desc_override(client->name)) {
+	if(i2c_hid_get_dmi_i2c_hid_desc_override()) {
 		i2c_hid_dbg(ihid, "Using a HID descriptor override\n");
-		ihid->hdesc =
-			*i2c_hid_get_dmi_i2c_hid_desc_override(client->name);
-	} else {
+		ihid->hdesc=*i2c_hid_get_dmi_i2c_hid_desc_override();
+	}
+	else {
 		i2c_hid_dbg(ihid, "Fetching the HID descriptor\n");
-		ret = i2c_hid_command(client, &hid_descr_cmd,
-				      ihid->hdesc_buffer,
+		ret = i2c_hid_command(client, &hid_descr_cmd, ihid->hdesc_buffer,
 				      sizeof(struct i2c_hid_desc));
 		if (ret) {
 			dev_err(&client->dev, "hid_descr_cmd failed\n");
@@ -906,15 +885,6 @@ static int i2c_hid_fetch_hid_descriptor(struct i2c_hid *ihid)
 }
 
 #ifdef CONFIG_ACPI
-static const struct acpi_device_id i2c_hid_acpi_blacklist[] = {
-	/*
-	 * The CHPN0001 ACPI device, which is used to describe the Chipone
-	 * ICN8505 controller, has a _CID of PNP0C50 but is not HID compatible.
-	 */
-	{"CHPN0001", 0 },
-	{ },
-};
-
 static int i2c_hid_acpi_pdata(struct i2c_client *client,
 		struct i2c_hid_platform_data *pdata)
 {
@@ -926,18 +896,13 @@ static int i2c_hid_acpi_pdata(struct i2c_client *client,
 	acpi_handle handle;
 
 	handle = ACPI_HANDLE(&client->dev);
-	if (!handle || acpi_bus_get_device(handle, &adev)) {
-		dev_err(&client->dev, "Error could not get ACPI device\n");
-		return -ENODEV;
-	}
-
-	if (acpi_match_device_ids(adev, i2c_hid_acpi_blacklist) == 0)
+	if (!handle || acpi_bus_get_device(handle, &adev))
 		return -ENODEV;
 
 	obj = acpi_evaluate_dsm_typed(handle, &i2c_hid_guid, 1, 1, NULL,
 				      ACPI_TYPE_INTEGER);
 	if (!obj) {
-		dev_err(&client->dev, "Error _DSM call to get HID descriptor address failed\n");
+		dev_err(&client->dev, "device _DSM execution failed\n");
 		return -ENODEV;
 	}
 
@@ -1042,18 +1007,21 @@ static int i2c_hid_probe(struct i2c_client *client,
 		return client->irq;
 	}
 
-	ihid = devm_kzalloc(&client->dev, sizeof(*ihid), GFP_KERNEL);
+	ihid = kzalloc(sizeof(struct i2c_hid), GFP_KERNEL);
 	if (!ihid)
 		return -ENOMEM;
 
 	if (client->dev.of_node) {
 		ret = i2c_hid_of_probe(client, &ihid->pdata);
 		if (ret)
-			return ret;
+			goto err;
 	} else if (!platform_data) {
 		ret = i2c_hid_acpi_pdata(client, &ihid->pdata);
-		if (ret)
-			return ret;
+		if (ret) {
+			dev_err(&client->dev,
+				"HID register address not provided\n");
+			goto err;
+		}
 	} else {
 		ihid->pdata = *platform_data;
 	}
@@ -1061,20 +1029,21 @@ static int i2c_hid_probe(struct i2c_client *client,
 	/* Parse platform agnostic common properties from ACPI / device tree */
 	i2c_hid_fwnode_probe(client, &ihid->pdata);
 
-	ihid->pdata.supplies[0].supply = "vdd";
-	ihid->pdata.supplies[1].supply = "vddl";
-
-	ret = devm_regulator_bulk_get(&client->dev,
-				      ARRAY_SIZE(ihid->pdata.supplies),
-				      ihid->pdata.supplies);
-	if (ret)
-		return ret;
-
-	ret = regulator_bulk_enable(ARRAY_SIZE(ihid->pdata.supplies),
-				    ihid->pdata.supplies);
-	if (ret < 0)
-		return ret;
+	ihid->pdata.supply = devm_regulator_get(&client->dev, "vdd");
+	if (IS_ERR(ihid->pdata.supply)) {
+		ret = PTR_ERR(ihid->pdata.supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&client->dev, "Failed to get regulator: %d\n",
+				ret);
+		goto err;
+	}
 
+	ret = regulator_enable(ihid->pdata.supply);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to enable regulator: %d\n",
+			ret);
+		goto err;
+	}
 	if (ihid->pdata.post_power_delay_ms)
 		msleep(ihid->pdata.post_power_delay_ms);
 
@@ -1102,14 +1071,6 @@ static int i2c_hid_probe(struct i2c_client *client,
 	pm_runtime_enable(&client->dev);
 	device_enable_async_suspend(&client->dev);
 
-	/* Make sure there is something at this address */
-	ret = i2c_smbus_read_byte(client);
-	if (ret < 0) {
-		dev_dbg(&client->dev, "nothing at this address: %d\n", ret);
-		ret = -ENXIO;
-		goto err_pm;
-	}
-
 	ret = i2c_hid_fetch_hid_descriptor(ihid);
 	if (ret < 0)
 		goto err_pm;
@@ -1147,9 +1108,7 @@ static int i2c_hid_probe(struct i2c_client *client,
 		goto err_mem_free;
 	}
 
-	if (!(ihid->quirks & I2C_HID_QUIRK_NO_RUNTIME_PM))
-		pm_runtime_put(&client->dev);
-
+	pm_runtime_put(&client->dev);
 	return 0;
 
 err_mem_free:
@@ -1163,9 +1122,11 @@ static int i2c_hid_probe(struct i2c_client *client,
 	pm_runtime_disable(&client->dev);
 
 err_regulator:
-	regulator_bulk_disable(ARRAY_SIZE(ihid->pdata.supplies),
-			       ihid->pdata.supplies);
+	regulator_disable(ihid->pdata.supply);
+
+err:
 	i2c_hid_free_buffers(ihid);
+	kfree(ihid);
 	return ret;
 }
 
@@ -1174,8 +1135,7 @@ static int i2c_hid_remove(struct i2c_client *client)
 	struct i2c_hid *ihid = i2c_get_clientdata(client);
 	struct hid_device *hid;
 
-	if (!(ihid->quirks & I2C_HID_QUIRK_NO_RUNTIME_PM))
-		pm_runtime_get_sync(&client->dev);
+	pm_runtime_get_sync(&client->dev);
 	pm_runtime_disable(&client->dev);
 	pm_runtime_set_suspended(&client->dev);
 	pm_runtime_put_noidle(&client->dev);
@@ -1188,8 +1148,9 @@ static int i2c_hid_remove(struct i2c_client *client)
 	if (ihid->bufsize)
 		i2c_hid_free_buffers(ihid);
 
-	regulator_bulk_disable(ARRAY_SIZE(ihid->pdata.supplies),
-			       ihid->pdata.supplies);
+	regulator_disable(ihid->pdata.supply);
+
+	kfree(ihid);
 
 	return 0;
 }
@@ -1240,8 +1201,9 @@ static int i2c_hid_suspend(struct device *dev)
 			hid_warn(hid, "Failed to enable irq wake: %d\n",
 				wake_status);
 	} else {
-		regulator_bulk_disable(ARRAY_SIZE(ihid->pdata.supplies),
-				       ihid->pdata.supplies);
+		ret = regulator_disable(ihid->pdata.supply);
+		if (ret < 0)
+			hid_warn(hid, "Failed to disable supply: %d\n", ret);
 	}
 
 	return 0;
@@ -1256,11 +1218,9 @@ static int i2c_hid_resume(struct device *dev)
 	int wake_status;
 
 	if (!device_may_wakeup(&client->dev)) {
-		ret = regulator_bulk_enable(ARRAY_SIZE(ihid->pdata.supplies),
-					    ihid->pdata.supplies);
-		if (ret)
-			hid_warn(hid, "Failed to enable supplies: %d\n", ret);
-
+		ret = regulator_enable(ihid->pdata.supply);
+		if (ret < 0)
+			hid_warn(hid, "Failed to enable supply: %d\n", ret);
 		if (ihid->pdata.post_power_delay_ms)
 			msleep(ihid->pdata.post_power_delay_ms);
 	} else if (ihid->irq_wake_enabled) {
@@ -1278,16 +1238,20 @@ static int i2c_hid_resume(struct device *dev)
 	pm_runtime_enable(dev);
 
 	enable_irq(client->irq);
-
-	/* Instead of resetting device, simply powers the device on. This
-	 * solves "incomplete reports" on Raydium devices 2386:3118 and
-	 * 2386:4B33 and fixes various SIS touchscreens no longer sending
-	 * data after a suspend/resume.
-	 */
-	ret = i2c_hid_set_power(client, I2C_HID_PWR_ON);
+	ret = i2c_hid_hwreset(client);
 	if (ret)
 		return ret;
 
+	/* RAYDIUM device (2386:3118) need to re-send report descr cmd
+	 * after resume, after this it will be back normal.
+	 * otherwise it issues too many incomplete reports.
+	 */
+	if (ihid->quirks & I2C_HID_QUIRK_RESEND_REPORT_DESCR) {
+		ret = i2c_hid_command(client, &hid_report_descr_cmd, NULL, 0);
+		if (ret)
+			return ret;
+	}
+
 	if (hid->driver && hid->driver->reset_resume) {
 		ret = hid->driver->reset_resume(hid);
 		return ret;
diff --git a/drivers/hid/i2c-hid/i2c-hid-dmi-quirks.c b/drivers/hid/i2c-hid/i2c-hid-dmi-quirks.c
index fd1b6eea6d2f..01c0e1b04112 100644
--- a/drivers/hid/i2c-hid/i2c-hid-dmi-quirks.c
+++ b/drivers/hid/i2c-hid/i2c-hid-dmi-quirks.c
@@ -1,13 +1,15 @@
-// SPDX-License-Identifier: GPL-2.0+
-
-/*
+/* 
  * Quirks for I2C-HID devices that do not supply proper descriptors
- *
- * Copyright (c) 2018 Julian Sax <jsbc@gmx.de>
- *
+ * 
+ * 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive for
+ * more details.
  */
 
 #include <linux/types.h>
+#include <linux/module.h>
+#include <linux/uuid.h>
 #include <linux/dmi.h>
 #include <linux/mod_devicetable.h>
 
@@ -21,271 +23,66 @@ struct i2c_hid_desc_override {
 	};
 	uint8_t              *hid_report_desc;
 	unsigned int          hid_report_desc_size;
-	uint8_t              *i2c_name;
 };
 
 
-/*
- * descriptors for the SIPODEV SP1064 touchpad
- *
- * This device does not supply any descriptors and on windows a filter
- * driver operates between the i2c-hid layer and the device and injects
- * these descriptors when the device is prompted. The descriptors were
- * extracted by listening to the i2c-hid traffic that occurs between the
- * windows filter driver and the windows i2c-hid driver.
- */
-
+/* descriptors for the SIPODEV SP1064 touchpad */
 static const struct i2c_hid_desc_override sipodev_desc = {
 	.i2c_hid_desc_buffer = (uint8_t [])
-	{0x1e, 0x00,                  /* Length of descriptor                 */
-	 0x00, 0x01,                  /* Version of descriptor                */
-	 0xdb, 0x01,                  /* Length of report descriptor          */
-	 0x21, 0x00,                  /* Location of report descriptor        */
-	 0x24, 0x00,                  /* Location of input report             */
-	 0x1b, 0x00,                  /* Max input report length              */
-	 0x25, 0x00,                  /* Location of output report            */
-	 0x11, 0x00,                  /* Max output report length             */
-	 0x22, 0x00,                  /* Location of command register         */
-	 0x23, 0x00,                  /* Location of data register            */
-	 0x11, 0x09,                  /* Vendor ID                            */
-	 0x88, 0x52,                  /* Product ID                           */
-	 0x06, 0x00,                  /* Version ID                           */
-	 0x00, 0x00, 0x00, 0x00       /* Reserved                             */
-	},
-
-	.hid_report_desc = (uint8_t [])
-	{0x05, 0x01,                  /* Usage Page (Desktop),                */
-	 0x09, 0x02,                  /* Usage (Mouse),                       */
-	 0xA1, 0x01,                  /* Collection (Application),            */
-	 0x85, 0x01,                  /*     Report ID (1),                   */
-	 0x09, 0x01,                  /*     Usage (Pointer),                 */
-	 0xA1, 0x00,                  /*     Collection (Physical),           */
-	 0x05, 0x09,                  /*         Usage Page (Button),         */
-	 0x19, 0x01,                  /*         Usage Minimum (01h),         */
-	 0x29, 0x02,                  /*         Usage Maximum (02h),         */
-	 0x25, 0x01,                  /*         Logical Maximum (1),         */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x95, 0x06,                  /*         Report Count (6),            */
-	 0x81, 0x01,                  /*         Input (Constant),            */
-	 0x05, 0x01,                  /*         Usage Page (Desktop),        */
-	 0x09, 0x30,                  /*         Usage (X),                   */
-	 0x09, 0x31,                  /*         Usage (Y),                   */
-	 0x15, 0x81,                  /*         Logical Minimum (-127),      */
-	 0x25, 0x7F,                  /*         Logical Maximum (127),       */
-	 0x75, 0x08,                  /*         Report Size (8),             */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x81, 0x06,                  /*         Input (Variable, Relative),  */
-	 0xC0,                        /*     End Collection,                  */
-	 0xC0,                        /* End Collection,                      */
-	 0x05, 0x0D,                  /* Usage Page (Digitizer),              */
-	 0x09, 0x05,                  /* Usage (Touchpad),                    */
-	 0xA1, 0x01,                  /* Collection (Application),            */
-	 0x85, 0x04,                  /*     Report ID (4),                   */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x09, 0x22,                  /*     Usage (Finger),                  */
-	 0xA1, 0x02,                  /*     Collection (Logical),            */
-	 0x15, 0x00,                  /*         Logical Minimum (0),         */
-	 0x25, 0x01,                  /*         Logical Maximum (1),         */
-	 0x09, 0x47,                  /*         Usage (Touch Valid),         */
-	 0x09, 0x42,                  /*         Usage (Tip Switch),          */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x75, 0x03,                  /*         Report Size (3),             */
-	 0x25, 0x05,                  /*         Logical Maximum (5),         */
-	 0x09, 0x51,                  /*         Usage (Contact Identifier),  */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x95, 0x03,                  /*         Report Count (3),            */
-	 0x81, 0x03,                  /*         Input (Constant, Variable),  */
-	 0x05, 0x01,                  /*         Usage Page (Desktop),        */
-	 0x26, 0x44, 0x0A,            /*         Logical Maximum (2628),      */
-	 0x75, 0x10,                  /*         Report Size (16),            */
-	 0x55, 0x0E,                  /*         Unit Exponent (14),          */
-	 0x65, 0x11,                  /*         Unit (Centimeter),           */
-	 0x09, 0x30,                  /*         Usage (X),                   */
-	 0x46, 0x1A, 0x04,            /*         Physical Maximum (1050),     */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x46, 0xBC, 0x02,            /*         Physical Maximum (700),      */
-	 0x26, 0x34, 0x05,            /*         Logical Maximum (1332),      */
-	 0x09, 0x31,                  /*         Usage (Y),                   */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0xC0,                        /*     End Collection,                  */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x09, 0x22,                  /*     Usage (Finger),                  */
-	 0xA1, 0x02,                  /*     Collection (Logical),            */
-	 0x25, 0x01,                  /*         Logical Maximum (1),         */
-	 0x09, 0x47,                  /*         Usage (Touch Valid),         */
-	 0x09, 0x42,                  /*         Usage (Tip Switch),          */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x75, 0x03,                  /*         Report Size (3),             */
-	 0x25, 0x05,                  /*         Logical Maximum (5),         */
-	 0x09, 0x51,                  /*         Usage (Contact Identifier),  */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x95, 0x03,                  /*         Report Count (3),            */
-	 0x81, 0x03,                  /*         Input (Constant, Variable),  */
-	 0x05, 0x01,                  /*         Usage Page (Desktop),        */
-	 0x26, 0x44, 0x0A,            /*         Logical Maximum (2628),      */
-	 0x75, 0x10,                  /*         Report Size (16),            */
-	 0x09, 0x30,                  /*         Usage (X),                   */
-	 0x46, 0x1A, 0x04,            /*         Physical Maximum (1050),     */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x46, 0xBC, 0x02,            /*         Physical Maximum (700),      */
-	 0x26, 0x34, 0x05,            /*         Logical Maximum (1332),      */
-	 0x09, 0x31,                  /*         Usage (Y),                   */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0xC0,                        /*     End Collection,                  */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x09, 0x22,                  /*     Usage (Finger),                  */
-	 0xA1, 0x02,                  /*     Collection (Logical),            */
-	 0x25, 0x01,                  /*         Logical Maximum (1),         */
-	 0x09, 0x47,                  /*         Usage (Touch Valid),         */
-	 0x09, 0x42,                  /*         Usage (Tip Switch),          */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x75, 0x03,                  /*         Report Size (3),             */
-	 0x25, 0x05,                  /*         Logical Maximum (5),         */
-	 0x09, 0x51,                  /*         Usage (Contact Identifier),  */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x95, 0x03,                  /*         Report Count (3),            */
-	 0x81, 0x03,                  /*         Input (Constant, Variable),  */
-	 0x05, 0x01,                  /*         Usage Page (Desktop),        */
-	 0x26, 0x44, 0x0A,            /*         Logical Maximum (2628),      */
-	 0x75, 0x10,                  /*         Report Size (16),            */
-	 0x09, 0x30,                  /*         Usage (X),                   */
-	 0x46, 0x1A, 0x04,            /*         Physical Maximum (1050),     */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x46, 0xBC, 0x02,            /*         Physical Maximum (700),      */
-	 0x26, 0x34, 0x05,            /*         Logical Maximum (1332),      */
-	 0x09, 0x31,                  /*         Usage (Y),                   */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0xC0,                        /*     End Collection,                  */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x09, 0x22,                  /*     Usage (Finger),                  */
-	 0xA1, 0x02,                  /*     Collection (Logical),            */
-	 0x25, 0x01,                  /*         Logical Maximum (1),         */
-	 0x09, 0x47,                  /*         Usage (Touch Valid),         */
-	 0x09, 0x42,                  /*         Usage (Tip Switch),          */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x75, 0x03,                  /*         Report Size (3),             */
-	 0x25, 0x05,                  /*         Logical Maximum (5),         */
-	 0x09, 0x51,                  /*         Usage (Contact Identifier),  */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x95, 0x03,                  /*         Report Count (3),            */
-	 0x81, 0x03,                  /*         Input (Constant, Variable),  */
-	 0x05, 0x01,                  /*         Usage Page (Desktop),        */
-	 0x26, 0x44, 0x0A,            /*         Logical Maximum (2628),      */
-	 0x75, 0x10,                  /*         Report Size (16),            */
-	 0x09, 0x30,                  /*         Usage (X),                   */
-	 0x46, 0x1A, 0x04,            /*         Physical Maximum (1050),     */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0x46, 0xBC, 0x02,            /*         Physical Maximum (700),      */
-	 0x26, 0x34, 0x05,            /*         Logical Maximum (1332),      */
-	 0x09, 0x31,                  /*         Usage (Y),                   */
-	 0x81, 0x02,                  /*         Input (Variable),            */
-	 0xC0,                        /*     End Collection,                  */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x55, 0x0C,                  /*     Unit Exponent (12),              */
-	 0x66, 0x01, 0x10,            /*     Unit (Seconds),                  */
-	 0x47, 0xFF, 0xFF, 0x00, 0x00,/*     Physical Maximum (65535),        */
-	 0x27, 0xFF, 0xFF, 0x00, 0x00,/*     Logical Maximum (65535),         */
-	 0x75, 0x10,                  /*     Report Size (16),                */
-	 0x95, 0x01,                  /*     Report Count (1),                */
-	 0x09, 0x56,                  /*     Usage (Scan Time),               */
-	 0x81, 0x02,                  /*     Input (Variable),                */
-	 0x09, 0x54,                  /*     Usage (Contact Count),           */
-	 0x25, 0x7F,                  /*     Logical Maximum (127),           */
-	 0x75, 0x08,                  /*     Report Size (8),                 */
-	 0x81, 0x02,                  /*     Input (Variable),                */
-	 0x05, 0x09,                  /*     Usage Page (Button),             */
-	 0x09, 0x01,                  /*     Usage (01h),                     */
-	 0x25, 0x01,                  /*     Logical Maximum (1),             */
-	 0x75, 0x01,                  /*     Report Size (1),                 */
-	 0x95, 0x01,                  /*     Report Count (1),                */
-	 0x81, 0x02,                  /*     Input (Variable),                */
-	 0x95, 0x07,                  /*     Report Count (7),                */
-	 0x81, 0x03,                  /*     Input (Constant, Variable),      */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x85, 0x02,                  /*     Report ID (2),                   */
-	 0x09, 0x55,                  /*     Usage (Contact Count Maximum),   */
-	 0x09, 0x59,                  /*     Usage (59h),                     */
-	 0x75, 0x04,                  /*     Report Size (4),                 */
-	 0x95, 0x02,                  /*     Report Count (2),                */
-	 0x25, 0x0F,                  /*     Logical Maximum (15),            */
-	 0xB1, 0x02,                  /*     Feature (Variable),              */
-	 0x05, 0x0D,                  /*     Usage Page (Digitizer),          */
-	 0x85, 0x07,                  /*     Report ID (7),                   */
-	 0x09, 0x60,                  /*     Usage (60h),                     */
-	 0x75, 0x01,                  /*     Report Size (1),                 */
-	 0x95, 0x01,                  /*     Report Count (1),                */
-	 0x25, 0x01,                  /*     Logical Maximum (1),             */
-	 0xB1, 0x02,                  /*     Feature (Variable),              */
-	 0x95, 0x07,                  /*     Report Count (7),                */
-	 0xB1, 0x03,                  /*     Feature (Constant, Variable),    */
-	 0x85, 0x06,                  /*     Report ID (6),                   */
-	 0x06, 0x00, 0xFF,            /*     Usage Page (FF00h),              */
-	 0x09, 0xC5,                  /*     Usage (C5h),                     */
-	 0x26, 0xFF, 0x00,            /*     Logical Maximum (255),           */
-	 0x75, 0x08,                  /*     Report Size (8),                 */
-	 0x96, 0x00, 0x01,            /*     Report Count (256),              */
-	 0xB1, 0x02,                  /*     Feature (Variable),              */
-	 0xC0,                        /* End Collection,                      */
-	 0x06, 0x00, 0xFF,            /* Usage Page (FF00h),                  */
-	 0x09, 0x01,                  /* Usage (01h),                         */
-	 0xA1, 0x01,                  /* Collection (Application),            */
-	 0x85, 0x0D,                  /*     Report ID (13),                  */
-	 0x26, 0xFF, 0x00,            /*     Logical Maximum (255),           */
-	 0x19, 0x01,                  /*     Usage Minimum (01h),             */
-	 0x29, 0x02,                  /*     Usage Maximum (02h),             */
-	 0x75, 0x08,                  /*     Report Size (8),                 */
-	 0x95, 0x02,                  /*     Report Count (2),                */
-	 0xB1, 0x02,                  /*     Feature (Variable),              */
-	 0xC0,                        /* End Collection,                      */
-	 0x05, 0x0D,                  /* Usage Page (Digitizer),              */
-	 0x09, 0x0E,                  /* Usage (Configuration),               */
-	 0xA1, 0x01,                  /* Collection (Application),            */
-	 0x85, 0x03,                  /*     Report ID (3),                   */
-	 0x09, 0x22,                  /*     Usage (Finger),                  */
-	 0xA1, 0x02,                  /*     Collection (Logical),            */
-	 0x09, 0x52,                  /*         Usage (Device Mode),         */
-	 0x25, 0x0A,                  /*         Logical Maximum (10),        */
-	 0x95, 0x01,                  /*         Report Count (1),            */
-	 0xB1, 0x02,                  /*         Feature (Variable),          */
-	 0xC0,                        /*     End Collection,                  */
-	 0x09, 0x22,                  /*     Usage (Finger),                  */
-	 0xA1, 0x00,                  /*     Collection (Physical),           */
-	 0x85, 0x05,                  /*         Report ID (5),               */
-	 0x09, 0x57,                  /*         Usage (57h),                 */
-	 0x09, 0x58,                  /*         Usage (58h),                 */
-	 0x75, 0x01,                  /*         Report Size (1),             */
-	 0x95, 0x02,                  /*         Report Count (2),            */
-	 0x25, 0x01,                  /*         Logical Maximum (1),         */
-	 0xB1, 0x02,                  /*         Feature (Variable),          */
-	 0x95, 0x06,                  /*         Report Count (6),            */
-	 0xB1, 0x03,                  /*         Feature (Constant, Variable),*/
-	 0xC0,                        /*     End Collection,                  */
-	 0xC0                         /* End Collection                       */
-	},
-	.hid_report_desc_size = 475,
-	.i2c_name = "SYNA3602:00"
+	{0x1e, 0x00, 0x00, 0x01, 0xdb, 0x01, 0x21, 0x00, 0x24, 0x00,
+	 0x1b, 0x00, 0x25, 0x00, 0x11, 0x00, 0x22, 0x00, 0x23, 0x00,
+	 0x11, 0x09, 0x88, 0x52, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00},
+	
+	.hid_report_desc = (uint8_t  [])
+	{0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x85, 0x01, 0x09, 0x01,
+	 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01, 0x29, 0x02, 0x25, 0x01,
+	 0x75, 0x01, 0x95, 0x02, 0x81, 0x02, 0x95, 0x06, 0x81, 0x01,
+	 0x05, 0x01, 0x09, 0x30, 0x09, 0x31, 0x15, 0x81, 0x25, 0x7f,
+	 0x75, 0x08, 0x95, 0x02, 0x81, 0x06, 0xc0, 0xc0, 0x05, 0x0d,
+	 0x09, 0x05, 0xa1, 0x01, 0x85, 0x04, 0x05, 0x0d, 0x09, 0x22,
+	 0xa1, 0x02, 0x15, 0x00, 0x25, 0x01, 0x09, 0x47, 0x09, 0x42,
+	 0x95, 0x02, 0x75, 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x03,
+	 0x25, 0x05, 0x09, 0x51, 0x81, 0x02, 0x75, 0x01, 0x95, 0x03,
+	 0x81, 0x03, 0x05, 0x01, 0x26, 0x44, 0x0a, 0x75, 0x10, 0x55,
+	 0x0e, 0x65, 0x11, 0x09, 0x30, 0x46, 0x1a, 0x04, 0x95, 0x01,
+	 0x81, 0x02, 0x46, 0xbc, 0x02, 0x26, 0x34, 0x05, 0x09, 0x31,
+	 0x81, 0x02, 0xc0, 0x05, 0x0d, 0x09, 0x22, 0xa1, 0x02, 0x25,
+	 0x01, 0x09, 0x47, 0x09, 0x42, 0x95, 0x02, 0x75, 0x01, 0x81,
+	 0x02, 0x95, 0x01, 0x75, 0x03, 0x25, 0x05, 0x09, 0x51, 0x81,
+	 0x02, 0x75, 0x01, 0x95, 0x03, 0x81, 0x03, 0x05, 0x01, 0x26,
+	 0x44, 0x0a, 0x75, 0x10, 0x09, 0x30, 0x46, 0x1a, 0x04, 0x95,
+	 0x01, 0x81, 0x02, 0x46, 0xbc, 0x02, 0x26, 0x34, 0x05, 0x09,
+	 0x31, 0x81, 0x02, 0xc0, 0x05, 0x0d, 0x09, 0x22, 0xa1, 0x02,
+	 0x25, 0x01, 0x09, 0x47, 0x09, 0x42, 0x95, 0x02, 0x75, 0x01,
+	 0x81, 0x02, 0x95, 0x01, 0x75, 0x03, 0x25, 0x05, 0x09, 0x51,
+	 0x81, 0x02, 0x75, 0x01, 0x95, 0x03, 0x81, 0x03, 0x05, 0x01,
+	 0x26, 0x44, 0x0a, 0x75, 0x10, 0x09, 0x30, 0x46, 0x1a, 0x04,
+	 0x95, 0x01, 0x81, 0x02, 0x46, 0xbc, 0x02, 0x26, 0x34, 0x05,
+	 0x09, 0x31, 0x81, 0x02, 0xc0, 0x05, 0x0d, 0x09, 0x22, 0xa1,
+	 0x02, 0x25, 0x01, 0x09, 0x47, 0x09, 0x42, 0x95, 0x02, 0x75,
+	 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x03, 0x25, 0x05, 0x09,
+	 0x51, 0x81, 0x02, 0x75, 0x01, 0x95, 0x03, 0x81, 0x03, 0x05,
+	 0x01, 0x26, 0x44, 0x0a, 0x75, 0x10, 0x09, 0x30, 0x46, 0x1a,
+	 0x04, 0x95, 0x01, 0x81, 0x02, 0x46, 0xbc, 0x02, 0x26, 0x34,
+	 0x05, 0x09, 0x31, 0x81, 0x02, 0xc0, 0x05, 0x0d, 0x55, 0x0c,
+	 0x66, 0x01, 0x10, 0x47, 0xff, 0xff, 0x00, 0x00, 0x27, 0xff,
+	 0xff, 0x00, 0x00, 0x75, 0x10, 0x95, 0x01, 0x09, 0x56, 0x81,
+	 0x02, 0x09, 0x54, 0x25, 0x7f, 0x75, 0x08, 0x81, 0x02, 0x05,
+	 0x09, 0x09, 0x01, 0x25, 0x01, 0x75, 0x01, 0x95, 0x01, 0x81,
+	 0x02, 0x95, 0x07, 0x81, 0x03, 0x05, 0x0d, 0x85, 0x02, 0x09,
+	 0x55, 0x09, 0x59, 0x75, 0x04, 0x95, 0x02, 0x25, 0x0f, 0xb1,
+	 0x02, 0x05, 0x0d, 0x85, 0x07, 0x09, 0x60, 0x75, 0x01, 0x95,
+	 0x01, 0x25, 0x01, 0xb1, 0x02, 0x95, 0x07, 0xb1, 0x03, 0x85,
+	 0x06, 0x06, 0x00, 0xff, 0x09, 0xc5, 0x26, 0xff, 0x00, 0x75,
+	 0x08, 0x96, 0x00, 0x01, 0xb1, 0x02, 0xc0, 0x06, 0x00, 0xff,
+	 0x09, 0x01, 0xa1, 0x01, 0x85, 0x0d, 0x26, 0xff, 0x00, 0x19,
+	 0x01, 0x29, 0x02, 0x75, 0x08, 0x95, 0x02, 0xb1, 0x02, 0xc0,
+	 0x05, 0x0d, 0x09, 0x0e, 0xa1, 0x01, 0x85, 0x03, 0x09, 0x22,
+	 0xa1, 0x02, 0x09, 0x52, 0x25, 0x0a, 0x95, 0x01, 0xb1, 0x02,
+	 0xc0, 0x09, 0x22, 0xa1, 0x00, 0x85, 0x05, 0x09, 0x57, 0x09,
+	 0x58, 0x75, 0x01, 0x95, 0x02, 0x25, 0x01, 0xb1, 0x02, 0x95,
+	 0x06, 0xb1, 0x03, 0xc0, 0xc0 },
+	.hid_report_desc_size=475
 };
 
 
@@ -321,73 +118,34 @@ static const struct dmi_system_id i2c_hid_dmi_desc_override_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Primebook C11"),
 		},
 		.driver_data = (void *)&sipodev_desc
-	},
-	{
-		.ident = "Direkt-Tek DTLAPY116-2",
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Direkt-Tek"),
-			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "DTLAPY116-2"),
-		},
-		.driver_data = (void *)&sipodev_desc
-	},
-	{
-		.ident = "Direkt-Tek DTLAPY133-1",
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Direkt-Tek"),
-			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "DTLAPY133-1"),
-		},
-		.driver_data = (void *)&sipodev_desc
-	},
-	{
-		.ident = "Mediacom Flexbook Edge 11",
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "MEDIACOM"),
-			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "FlexBook edge11 - M-FBE11"),
-		},
-		.driver_data = (void *)&sipodev_desc
-	},
-	{
-		.ident = "Odys Winbook 13",
-		.matches = {
-			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AXDIA International GmbH"),
-			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "WINBOOK 13"),
-		},
-		.driver_data = (void *)&sipodev_desc
-	},
-	{ }	/* Terminate list */
+	}
 };
 
 
-struct i2c_hid_desc *i2c_hid_get_dmi_i2c_hid_desc_override(uint8_t *i2c_name)
+struct i2c_hid_desc *i2c_hid_get_dmi_i2c_hid_desc_override(void)
 {
 	struct i2c_hid_desc_override *override;
 	const struct dmi_system_id *system_id;
-
+        
 	system_id = dmi_first_match(i2c_hid_dmi_desc_override_table);
 	if (!system_id)
 		return NULL;
 
 	override = system_id->driver_data;
-	if (strcmp(override->i2c_name, i2c_name))
-		return NULL;
-
 	return override->i2c_hid_desc;
 }
 
-char *i2c_hid_get_dmi_hid_report_desc_override(uint8_t *i2c_name,
-					       unsigned int *size)
+char *i2c_hid_get_dmi_hid_report_desc_override(unsigned int *size)
 {
 	struct i2c_hid_desc_override *override;
 	const struct dmi_system_id *system_id;
-
+        
 	system_id = dmi_first_match(i2c_hid_dmi_desc_override_table);
 	if (!system_id)
 		return NULL;
 
 	override = system_id->driver_data;
-	if (strcmp(override->i2c_name, i2c_name))
-		return NULL;
-
 	*size = override->hid_report_desc_size;
 	return override->hid_report_desc;
 }
+
diff --git a/drivers/hid/i2c-hid/i2c-hid.h b/drivers/hid/i2c-hid/i2c-hid.h
index a8c19aef5824..1338530d3f30 100644
--- a/drivers/hid/i2c-hid/i2c-hid.h
+++ b/drivers/hid/i2c-hid/i2c-hid.h
@@ -1,19 +1,14 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-
 #ifndef I2C_HID_H
 #define I2C_HID_H
 
 
 #ifdef CONFIG_DMI
-struct i2c_hid_desc *i2c_hid_get_dmi_i2c_hid_desc_override(uint8_t *i2c_name);
-char *i2c_hid_get_dmi_hid_report_desc_override(uint8_t *i2c_name,
-					       unsigned int *size);
+struct i2c_hid_desc *i2c_hid_get_dmi_i2c_hid_desc_override(void);
+char *i2c_hid_get_dmi_hid_report_desc_override(unsigned int *size);
 #else
-static inline struct i2c_hid_desc
-		   *i2c_hid_get_dmi_i2c_hid_desc_override(uint8_t *i2c_name)
+static inline struct i2c_hid_desc *i2c_hid_get_dmi_i2c_hid_desc_override(void)
 { return NULL; }
-static inline char *i2c_hid_get_dmi_hid_report_desc_override(uint8_t *i2c_name,
-							     unsigned int *size)
+static inline char *i2c_hid_get_dmi_hid_report_desc_override(unsigned int *size)
 { return NULL; }
 #endif
 
